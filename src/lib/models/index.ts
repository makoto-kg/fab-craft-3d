/**
 * Model loading via GLTFLoader from pre-built GLB files.
 *
 * GLB files live in /public/models/{TYPE}.glb
 * They are generated by scripts/gen_models.py
 */
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { EquipmentType } from '../types';
import { EQUIPMENT_TYPES } from '../equipmentDefs';

// ─── GLB loading ──────────────────────────────────────────────────────────────

const loader = new GLTFLoader();

/** basePath from Next.js build-time env (set via BASE_PATH env var). */
const BASE = process.env.NEXT_PUBLIC_BASE_PATH ?? '';

/** Load a single GLB, return its root scene as a Group */
function loadGLB(type: EquipmentType): Promise<THREE.Group> {
  return new Promise((resolve, reject) => {
    loader.load(
      `${BASE}/models/${type}.glb`,
      (gltf) => {
        const group = gltf.scene as unknown as THREE.Group;
        group.userData.type = type;
        // Ensure all child meshes cast/receive shadows
        group.traverse((child) => {
          if ((child as THREE.Mesh).isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });
        resolve(group);
      },
      undefined,
      (err) => reject(new Error(`Failed to load ${type}.glb: ${String(err)}`)),
    );
  });
}

/** Preload all equipment GLB models into a cache Map */
export async function preloadAllModels(): Promise<Map<EquipmentType, THREE.Group>> {
  const cache = new Map<EquipmentType, THREE.Group>();
  await Promise.all(
    EQUIPMENT_TYPES.map(async (type) => {
      const group = await loadGLB(type);
      cache.set(type, group);
    }),
  );
  return cache;
}

/** Clone a model from the cache (deep-clone so each instance is independent) */
export function cloneModel(
  cache: Map<EquipmentType, THREE.Group>,
  type: EquipmentType,
): THREE.Group {
  const template = cache.get(type);
  if (!template) {
    // Fallback: return an empty group with a visible placeholder box
    const fallback = new THREE.Group();
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: 0xff00ff, wireframe: true }),
    );
    fallback.add(mesh);
    fallback.userData.type = type;
    return fallback;
  }
  const clone = template.clone(true) as THREE.Group;
  clone.userData.type = type;
  return clone;
}

/** Apply ghost (semi-transparent) material to a model group in-place */
export function applyGhostMaterial(group: THREE.Group): void {
  group.traverse((child) => {
    if ((child as THREE.Mesh).isMesh) {
      const mesh = child as THREE.Mesh;
      const applyOne = (m: THREE.Material): THREE.Material => {
        const c = m.clone();
        c.transparent = true;
        (c as THREE.MeshStandardMaterial).opacity = 0.40;
        return c;
      };
      if (Array.isArray(mesh.material)) {
        mesh.material = mesh.material.map(applyOne);
      } else {
        mesh.material = applyOne(mesh.material);
      }
    }
  });
}
